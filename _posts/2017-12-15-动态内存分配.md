动态内存分配器，对于c语言，c标准库提供了malloc和free，可以在运行时刻申请额外的内存。其实，完全可以通过mmap和munmap来创建和删除内存区域(areas)，不过动态内存分配器更方便（malloc其实就是使用了mmap、munmap、sbrk这些系统调用，sbrk用来伸缩堆）。

![堆](/assets/img/dynamic_memory_allocation/heap.png)

动态内存分配器维护进程的内存中一个叫做堆的区域。可以认为堆是一个demand-zero的内存区域，在bss区域的上面向上增长（向高地址）。内核为每个进程维护了一个brk变量指向堆的顶部。分配器将堆组织为一个集合，集合里的元素是一个个大小不等的blocks，每一个block是一块连续的内存，要么已分配(allocated)，要么未分配(空闲，free)。

* 已分配block显式的被应用程序申请使用，直到被释放，变成未分配的block。释放要么显示的被应用程序释放，要么被分配器自己隐式的释放。
* 未分配block可以被分配。可以通过被应用程序显示的申请变成已分配。

分配器有两种方式，两者都要求应用程序显示申请内存，区别在于谁负责释放已分配的blocks。

* 显示分配器：需要应用程序显示的释放所有的已分配blocks。比如上面提到的c语言里的malloc和free，还有c++里的new和delete
* 隐式分配器：分配器会检测何时已分配blocks不再使用了，然后释放。隐式分配器也被称为垃圾回收器(garbage collectors)，自动释放不再使用的已分配块的过程叫做垃圾回收。比如高级语言Lisp，ML，Java。

本文介绍显示分配器。



### 显式分配器需要满足的条件

1. 处理任意请求序列。应用程序可以有任意的分配请求操作和释放操作，只要满足一个约束：每一个释放请求都对应一个当前已经分配的block，这个block是通过之前的分配请求操作获得的。因此，分配器不能假定分配和释放的顺序。
2. 对请求立即响应。分配器必须立即响应分配请求，因此，分配器不能为了性能而重新调整分配请求的顺序，或者buffer请求。
3. 只能使用堆。为了分配器的可伸缩，所有分配器使用的非标量数据结构必须存在堆里。
4. 对齐blocks。为了blocks能存放任意类型的数据对象，分配器必须对齐blocks。对于大多数系统，分配器返回的blocks需要8字节（2个字）对齐。
5. 不能修改已分配的blocks。分配器只能操作空闲块，不能修改或移动已分配blocks。所以，有些技术，比如压缩已分配blocks，是不允许的。

### 分配器的目标

1. 最大化吞吐量。吞吐量指的是分配器每秒完成的分配或者释放请求数。
2. 最大化内存利用。内存是有限的资源，一个系统上所有进程能够申请的内存总和受限于磁盘上交换空间(swap space)的大小，所以一个好的分配器应该有较高的内存利用率。



内存利用率一个比较好的衡量指标叫做峰值利用率。应用程序申请一个p字节的block，那么这个block的有效载荷（block的大小>=p字节，等下会解释）就是p字节。当k个分配或释放请求完成后，当前所有已分配blocks的有效载荷之和（就是应用程序申请还未释放的内存大小之和）记为Pk，当前的堆大小记为Hk（假设单调非递减）。假设有一个长度为n的分配和释放请求序列，那么这n个请求的峰值利用率，记为Un就等于：

​                                                         *Un = MAX(Pi, i <= n) / Hn*

以上两个目标其实是冲突的，要实现一个吞吐量很高的分配器很容易，比如分配操作直接从上次分配的block后分配一个新的block，而释放操作则什么也不做，但是这样内存利用率相当低。所以一个好的分配器会在这两者间找到一个平衡。



