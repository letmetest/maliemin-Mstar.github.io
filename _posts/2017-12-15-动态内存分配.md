动态内存分配器，对于c语言，c标准库提供了malloc和free，可以在运行时刻申请额外的内存。其实，完全可以通过mmap和munmap来创建和删除内存区域(areas)，不过动态内存分配器更方便（malloc其实就是使用了mmap、munmap、sbrk这些系统调用，sbrk用来伸缩堆）。

![堆](/assets/img/dynamic_memory_allocation/heap.png)

动态内存分配器维护进程的内存中一个叫做堆的区域。可以认为堆是一个demand-zero的内存区域，在bss区域的上面向上增长（向高地址）。内核为每个进程维护了一个brk变量指向堆的顶部。分配器将堆组织为一个集合，集合里的元素是一个个大小不等的blocks，每一个block是一块连续的内存，要么已分配(allocated)，要么未分配(空闲，free)。

* 已分配block显式的被应用程序申请使用，直到被释放，变成未分配的block。释放要么显示的被应用程序释放，要么被分配器自己隐式的释放。
* 未分配block可以被分配。可以通过被应用程序显示的申请变成已分配。

分配器有两种方式，两者都要求应用程序显示申请内存，区别在于谁负责释放已分配的blocks。

* 显示分配器：需要应用程序显示的释放所有的已分配blocks。比如上面提到的c语言里的malloc和free，还有c++里的new和delete
* 隐式分配器：分配器会检测何时已分配blocks不再使用了，然后释放。隐式分配器也被称为垃圾回收器(garbage collectors)，自动释放不再使用的已分配块的过程叫做垃圾回收。比如高级语言Lisp，ML，Java。

本文介绍显示分配器。



### 显式分配器需要满足的条件

1. 处理任意请求序列。应用程序可以有任意的分配请求操作和释放操作，只要满足一个约束：每一个释放请求都对应一个当前已经分配的block，这个block是通过之前的分配请求操作获得的。因此，分配器不能假定分配和释放的顺序。
2. 对请求立即响应。分配器必须立即响应分配请求，因此，分配器不能为了性能而重新调整分配请求的顺序，或者buffer请求。
3. 只能使用堆。为了分配器的可伸缩，所有分配器使用的非标量数据结构必须存在堆里。
4. 对齐blocks。为了blocks能存放任意类型的数据对象，分配器必须对齐blocks。对于大多数系统，分配器返回的blocks需要8字节（2个字）对齐。
5. 不能修改已分配的blocks。分配器只能操作空闲块，不能修改或移动已分配blocks。所以，有些技术，比如压缩已分配blocks，是不允许的。

### 分配器的目标

1. 最大化吞吐量（时间效率）。吞吐量指的是分配器每秒完成的分配或者释放请求数。
2. 最大化内存利用（空间效率）。内存是有限的资源，一个系统上所有进程能够申请的内存总和受限于磁盘上交换空间(swap space)的大小，所以一个好的分配器应该有较高的内存利用率。



内存利用率一个比较好的衡量指标叫做峰值利用率。应用程序申请一个p字节的block，那么这个block的有效载荷（block的大小>=p字节，等下会解释）就是p字节。当k个分配或释放请求完成后，当前所有已分配blocks的有效载荷之和（就是应用程序申请还未释放的内存大小之和）记为Pk，当前的堆大小记为Hk（假设单调非递减）。假设有一个长度为n的分配和释放请求序列，那么这n个请求的峰值利用率，记为Un就等于：

*Un = MAX(Pi, i <= n) / Hn*

以上两个目标其实是冲突的，要实现一个吞吐量很高的分配器很容易，比如分配操作直接从上次分配的block后分配一个新的block，而释放操作则什么也不做，但是这样内存利用率相当低。所以一个好的分配器会在这两者间找到一个平衡。

### 碎片###

内存利用率低的原因是存在一种叫做碎片的现象。碎片就是未分配的内存blocks不能满足内存申请的大小。碎片分为内部碎片和外部碎片。

* 当分配的block的大小大于有效载荷（应用程序请求的大小），即为内部碎片。比如，分配器的实现要求有最小的block大小，但是请求的内存小于这个大小。或者，分配器为了满足对齐要求，会填充一些内存。内部碎片很容易量化，它的值就等于所有已分配块的大小和有效载荷之间的差的总和。
* 当堆里有很多小的未分配blocks，他们的总大小大于请求分配的内存大，但是没有一个单独的未分配block比请求的大。这种情况下，分配器只能向内核申请更多的内存来满足请求。外部碎片很难量化，它跟已经分配的blocks、分配器的实现有关，更与未来分配的blocks有关。举个简单的例子，比如之后的所有分配请求都是很小的内存，那么ok；一旦请求很大的内存，那么就会出现外部碎片的现象。

由于外部碎片的这些特点，一般分配器都是尽量维护少量的大的未分配blocks而不是大量的小的未分配blocks。

### 分配器实现的一些问题 ###

一个实际的分配器会平衡吞吐量和内存利用率，主要考虑一下几个问题

* 空闲blocks的组织：如何找到一个空闲block
* 放置：为了分配一个block，如何选取一个合适的block
* 分裂：在一个空闲block里放置了以后，这个空闲block剩下的部分要怎么处理
* 合并：释放一个block后，改怎么处理？

下面通过隐式空闲blocks链表的例子来介绍一下解决这些问题的技术

### 隐式空闲链表 ###

隐式空闲链表的每个block结构如下：

![block](/assets/img/dynamic_memory_allocation/implicit-free-list-block1.png)

一个block由一个字的header、有效载荷和可能存在的填充组成。header中包含了block的大小（大小等于header加上有效载荷加上可能的填充大小）和是否已分配的标记。如果要满足8字节对齐的要求，那么block的大小就是8的倍数，所以最低的三位都是0。因此，最低的三位可以用来存别的东西，而block的大小存在高的29位。这里把是否已分配的标记记在最低位。有效载荷就是应用程序请求内存时返回的，后面的填充是为了满足对齐要求，或者分配器为了优化外部碎片而定的策略。有了这样的block的结构，堆就可以被组织成一个由空闲和已分配的blocks组成的序列了，如图（16/1的意思是：大小16字节/已分配。开头和结尾有一些特殊的block）：

![list](/assets/img/dynamic_memory_allocation/implicit-free-list.png)

之所以叫做隐式空闲链表是因为空闲blocks是通过header里存的的大小字段隐式的链接起来的。隐式空闲链表的好处是简单，坏处是找到一个合适的空闲block时间复杂度是O(n)的。

还有一个要注意的是，由于系统要求8字节对齐，所以每个block的大小必须是8的倍数，这就要求空闲block和已分配block都至少是8字节(header4字节，另外4字节为了对齐)。比如申请1个字节，分配器依旧创建一个8字节的block，这个时候填充就是3字节，求block大小的算法就是求大于等于4 + 1的最小的8的倍数。

##### 放置分配block #####

当应用程序请求分配内存时，分配器会找一个足够大的空闲block来放置，常见的放置策略有：

* first fit：每次从头开始查找，找到第一个满足条件的空闲block。好处是会趋向于在链表尾部产生大的空闲blocks，坏处是在链表前面会产生很多小的空闲blocks，增加查找大blocks的时间。
* next fit：从上一次查找到的位置之后开始查找。趋势上可以解决first fit的问题，但是潜在的问题是内存利用率比first fit低。
* best fit：每次查找会遍历整个链表，找到最下的满足要求的空闲block。好处很明显，会增加内存利用率，坏处是时间复杂度高。

##### 分裂空闲block #####

当选定了一个空闲block后，如何使用这个空闲block？最简单的，可以把整个空闲block都利用了，但这样会有内部碎片的现象。也可以把空闲block分为两部分，一部分变成已分配，剩下的部分变成一个新的空闲block。

##### 合并空闲blocks #####

当分配器释放一个已分配block时，和这个block相邻的blocks也可能是空闲的，这可能会导致一中称为*假碎片*的现象，它们之间的每一个都不足以满足一个内存请求，但是他们的大小之和却足够大。为了解决这个问题，分配器需要合并相邻的空闲blocks。这里又出现了一个策略问题，什么时候合并？最简单的，可以在每次释放时立即合并。或者，可以延迟合并，比如分配器可以在无法满足分配请求的时候，遍历整个链表，合并所有空闲blocks。

立即合并有一个问题就是，假如有一种请求内存的模式不停地做请求-释放这样的循环，这会导致分配器在做无意义的分裂-合并操作。所以，更快的分配器都会选择某种形式的延迟合并。

##### 获取更多的堆内存 #####

假设空闲blocks都已经合并了，然而分配器还是找不到放得下的空闲block该怎么办？这时分配器只能向内核申请额外的堆内存，方法是通过sbrk系统调用。然后，分配器把申请的内存当做一个大的空闲block插入到链表中，再在这个block里放置应用程序请求的block。

##### 使用边界标记来合并 #####

假设分配器使用立即合并的策略，当释放一个block时，要判断是否和下一个block合并很简单，由于当前block的header指向下一个block的header，所以可以知道下一个block是否是空闲的。如果是，就把它的大小和当前block的大小加起来，写入当前block的header，O(1)即可完成。那么如何和之前的block合并呢？其实，当前的blocks结构就和单链表一样，求某个元素的前一个元素只能通过遍历链表，所以，想要实现O(1)的时间找到前一个元素就可以使用双向链表：

![block](/assets/img/dynamic_memory_allocation/implicit-free-list-block2.png)

也就是在每个block的后面加了一个footer，它的内容和header一样。这样，当前block就可以从距离它开始地址4个字节的地址读取前一个block的信息了。在这种结构下，最小空闲block的大小为4字节的header加4字节的footer等于8字节，最小已分配block（有效载荷不能为空）的大小为4 + 4 + 1 = 9，对齐后就是16字节，由于一个block可以在空闲和已分配两种状态间切换，所以这种结构的最小block大小就是max(8, 16) = 16。

由于要考虑当前block的前面的block和后面的block，所以一共有4种情况，如图（n为当前block，a：allocated，f：free）：

![coalescing](/assets/img/dynamic_memory_allocation/implicit-free-list-block-coalescing.png)

这种结构的block，由于多了一个footer，会增加内存开销。比如有许多8字节的内存请求，header和footer就会占据了一半的开销。有一个优化的方法：合并空闲blocks的时候，只有当前一个block是空闲的情况下才需要根据前一个block的footer得到它的大小，所以已分配的block可以不需要footer，但是怎么知道前一个block是已分配还是空闲呢？回想一下，header里的最低三位都是可用的，而目前只用了最低位来标记当前block是否已分配，所以可以用剩下的两个中的任意一个来保存前一个block是否已分配。

